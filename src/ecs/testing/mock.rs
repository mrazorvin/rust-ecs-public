#[allow(unused_macros)]
/// This macro allows developers for easy mocking any part of macro or function,
/// inside unit tests.
///
/// #### Implementation:  
/// Calling expression with `mock_run!(func())`  
/// setup `#[thread_local] mock`. If `func()` contains `mock_setup!()`  
/// at the start of function body, then mock in `#[thread_local]` will be consumed.
///  
/// Such implementations allows us to provides thread safe mock per function invocation,  
/// include recursive function calls `func(|| { func() })`
///
/// #### Note:  
/// Structures and globals generated by this macro available  
/// only inside current file
/// This means that to test your macros you need to disable access to global symbols  
/// this could be done via conditional compilation mock_setup!(..., false)  
macro_rules! mock {
  ($class:ident { $($name:ident: $type:ty),* }) => {
    crate::ecs::testing::mock!(false, $class { $($name: $type),* });
  };
  // when {$in_sequence} enabled, every new code execution
  // will be started only when previous execution was completed
  // even if function not contains any mock_value!
  ($in_sequence:expr, $class:ident { $($name:ident: $type:ty),* }) => {
    paste::paste! {
      // #region ### Mock - State
      #[cfg(test)]
      #[derive(::std::default::Default)]
      struct $class {
        $($name: $crate::ecs::testing::Placeholder<$type>),*
      }
      // #endregion

      // #region ### Mock - Globals
      #[cfg(test)]
      #[thread_local]
      static mut [<$class:upper _STATE>]: Option<$class> = None;

      #[cfg(test)]
      static [<$class:upper _SEQUENCE>]: ::std::sync::atomic::AtomicU64 = ::std::sync::atomic::AtomicU64::new(0);
      // #endregion

      // #region ### Mock - Guard
      #[cfg(test)]
      struct [<$class Guard>]<T> { state: Option<T> }

      #[cfg(test)]
      impl<T> [<$class Guard>]<T> {
        fn new(state: Option<T>) -> [<$class Guard>]<T> {
          if $in_sequence {
            while [<$class:upper _SEQUENCE>].compare_exchange(0, 1, ::std::sync::atomic::Ordering::SeqCst, ::std::sync::atomic::Ordering::SeqCst).is_err() {
            }
          }
          [<$class Guard>] { state }
        }
      }

      #[cfg(test)]
      impl<T> Drop for [<$class Guard>]<T> {
        fn drop(&mut self) {
          if $in_sequence {
            [<$class:upper _SEQUENCE>].fetch_sub(1, ::std::sync::atomic::Ordering::SeqCst);
          }
        }
      }
      // #endregion
    }
  }
}

#[allow(unused_imports)]
pub(crate) use mock;

#[allow(unused_macros)]
macro_rules! mock_setup {
  // #region ### Mock setup - conditional compliation
  // following macro is no-op, but
  // it allows us to use mock! inside
  // other macro, check logger.rs
  ($class:ident, false) => {
    #[allow(unused_macros)]
    macro_rules! mock_value {
      ($$($body:tt)*) => {}
    }
  };
  // #endregion

  // #region ### Mock setup - guard & mock_value!
  ($class:ident, true) => {
    paste::paste! {
      #[cfg(test)]
      #[allow(unused_variables)]
      let mut [<$class:lower _guard>] = [<$class Guard>]::new(unsafe { [<$class:upper _STATE>].take() });

      #[allow(unused_macros)]
      // reading value from mock
      macro_rules! mock_value {
        ($release:expr,  $$($body:tt)*) => {{
          paste::paste! {
            #[cfg(not(test))]
            let result = $release;

            #[cfg(test)]
            let result = {
              if ([<$class:lower _guard>].state.is_some()) {
                let func = $$($body)*;
                func([<$class:lower _guard>].state.as_mut().unwrap())
              } else {
                $release
              }
            };

            result
          }
        }}
      }
    }
  };
  // #endregion
}

#[allow(unused_imports)]
pub(crate) use mock_setup;

#[allow(unused_macros)]
macro_rules! mock_run {
    ($exec:expr, |$param:ident: &mut $class:ident| { $($body:tt)* }) => {{
        paste::paste! {
          let mut $param = $class::default();
          $($body)*
          unsafe { [<$class:upper _STATE>] = Some($param) };
          let result = $exec;
          unsafe { [<$class:upper _STATE>] = None };
          result
        }}
    };
}

#[allow(unused_imports)]
pub(crate) use mock_run;

#[test]
fn mock_is_unique_per_func_run() {
    use std::time::Duration;

    mock!(Context { time: u64 });

    fn mock_testing() -> u64 {
        mock_setup!(Context, true);
        mock_value!(100, |ctx: &mut Context| { *ctx.time })
    }

    let main_thread_result = mock_run!(mock_testing(), |state: &mut Context| {
        state.time.replace(256);
        std::thread::sleep(Duration::from_millis(100));
    });

    let child_thread_result = std::thread::spawn(|| mock_testing());

    assert_eq!(child_thread_result.join().unwrap(), 100);
    assert_eq!(main_thread_result, 256);
}

#[test]
fn mock_non_seq_runs() {
    #![allow(unused_mut)]

    use std::sync::{Arc, Mutex};
    use std::time::Duration;

    mock!(false, Context {});

    let vec = Arc::new(Mutex::new(Vec::new()));

    let vec1 = vec.clone();
    let handler1 = std::thread::spawn(move || {
        mock_setup!(Context, true);
        std::thread::sleep(Duration::from_millis(200));
        let _ = vec1.lock().map(|mut value| {
            value.push(1);
        });
    });

    let vec2 = vec.clone();
    let handler2 = std::thread::spawn(move || {
        std::thread::sleep(Duration::from_millis(100));
        mock_setup!(Context, true);
        let _ = vec2.lock().map(|mut value| {
            value.push(2);
        });
    });

    let _ = handler1.join();
    let _ = handler2.join();

    assert_eq!(vec.lock().unwrap().clone(), vec![2, 1]);
}

#[test]
fn mock_seq_runs() {
    #![allow(unused_mut)]

    use std::sync::{Arc, Mutex};
    use std::time::Duration;

    mock!(true, Context {});

    let vec = Arc::new(Mutex::new(Vec::new()));

    let vec1 = vec.clone();
    let handler1 = std::thread::spawn(move || {
        mock_setup!(Context, true);
        std::thread::sleep(Duration::from_millis(200));
        let _ = vec1.lock().map(|mut value| {
            value.push(1);
        });
    });

    let vec2 = vec.clone();
    let handler2 = std::thread::spawn(move || {
        std::thread::sleep(Duration::from_millis(100));
        mock_setup!(Context, true);
        let _ = vec2.lock().map(|mut value| {
            value.push(2);
        });
    });

    let _ = handler1.join();
    let _ = handler2.join();

    assert_eq!(vec.lock().unwrap().clone(), vec![1, 2]);
}
